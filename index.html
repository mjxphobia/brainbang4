<!doctype html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>ZOMBIE CITY4</title>

<style>
body{
  margin:0;
  background:#ffffff;
  font-family: Arial, Helvetica, sans-serif;
  color:#111;
}
.wrap{ width:100%; text-align:center; }

.title{
  font-size:22px;
  font-weight:700;
  margin:18px 0 10px;
}

/* ✅ 카드 */
.card{
  width:1024px;
  height:768px;
  max-width:92vw;
  margin:0 auto;
  border:2px solid #111;
  position:relative;
  overflow:hidden;
  background:#fff;
}
.layer{
  position:absolute;
  inset:0;
  display:flex;
  align-items:center;
  justify-content:center;
}

/* ✅ city 흔들림 */
#cityImg{
  height:100%;
  width:auto;
  position:absolute;
  left:50%;
  transform:translateX(-50%);
  user-select:none;
  pointer-events:none;
}

/* ✅ overlays */
#zombieImg,#puzzleImg{
  width:100%;
  height:100%;
  object-fit:contain;
  display:none;
  user-select:none;
  pointer-events:none;
}

/* ✅ 메시지 오버레이(데미지 등) */
.msg{
  position:absolute;
  inset:0;
  display:none;
  align-items:center;
  justify-content:center;
  background:rgba(255,255,255,0.75);
  font-weight:800;
  font-size:34px;
  z-index:6;
  text-align:center;
  padding:20px;
  box-sizing:border-box;
}
.msg.show{ display:flex; }

/* ✅ 퍼즐 UI */
.ui{
  width:1024px;
  max-width:92vw;
  margin:10px auto 0;
}
.timer{
  font-family: ui-monospace, monospace;
  font-size:48px;
  display:none;
}
.answerRow{
  display:none;
  margin-top:8px;
}
input{
  border:2px solid #111;
  padding:12px;
  font-size:18px;
  width:260px;
  text-align:center;
}

/* ✅ 상단 컨트롤 */
.controls{
  width:1024px;
  max-width:92vw;
  margin:14px auto 10px;
  display:grid;
  grid-template-columns: 1fr auto auto;
  gap:10px;
  align-items:center;
}
.ctrlLeft{
  display:flex;
  justify-content:flex-start;
}
.ctrlMid{
  display:flex;
  justify-content:center;
  gap:12px;
  align-items:center;
  border:2px solid #111;
  padding:10px 12px;
  box-sizing:border-box;
}
#stopwatch{
  font-family: ui-monospace, monospace;
  font-size:22px;
  letter-spacing:1px;
  min-width:110px;
}
#modeLabel{
  font-weight:700;
  font-size:18px;
  min-width:44px;
}
.ctrlRight{
  display:flex;
  justify-content:flex-end;
  gap:10px;
}

button{
  border:2px solid #111;
  background:#fff;
  padding:12px;
  font-size:16px;
  cursor:pointer;
}
button:active{ transform: translateY(1px); }

.note{
  width:1024px;
  max-width:92vw;
  margin:0 auto 14px;
  font-size:12px;
  opacity:0.75;
  text-align:left;
}
</style>
</head>

<body>
<div class="wrap">

  <div class="title">ZOMBIE CITY4</div>

  <div class="controls">
    <div class="ctrlLeft">
      <button onclick="show('restart')">다시 시작</button>
    </div>

    <div class="ctrlMid">
      <div id="stopwatch">00:00.00</div>
      <div id="modeLabel">밤</div>
    </div>

    <div class="ctrlRight">
      <button onclick="show('toggle')">▶/ II</button>
      <button onclick="show('ff')">앞으로 빨리감기</button>
      <button onclick="show('normal')">정속감기</button>
      <button onclick="show('rew')">뒤로 빨리감기</button>
    </div>
  </div>

  <div class="card">
    <div class="layer"><img id="cityImg"></div>
    <div class="layer"><img id="zombieImg"></div>
    <div class="layer"><img id="puzzleImg"></div>
    <div class="msg" id="msg"></div>
  </div>

  <div class="ui">
    <div id="timer" class="timer">20</div>
    <div id="answerRow" class="answerRow">
      <input id="answerInput"
             placeholder="ANSWER"
             autocomplete="off"
             autocapitalize="characters"
             autocorrect="off"
             spellcheck="false"
             inputmode="latin"
             lang="en">
      <div>ENTER 누르기</div>
    </div>
  </div>

  <div class="note">
    * 시작은 밤(재생) 상태.
    <br>* <b>0</b>: (밤+CITY일 때만) <b>zombie1~5</b> 중 랜덤 소환
    <br>* <b>-</b>: (밤+CITY일 때만) <b>zombie6~8</b> 중 랜덤 소환
    <br>* 좀비 뜨면 5초 카운트다운 → Space를 눌러야 퍼즐 진입(20초). (단 zombie6~8은 Space 즉시 fail2)
    <br>* <b>9</b>: 좀비/퍼즐/결과 중 “강제 취소” → 밤 CITY로 즉시 복귀 (스킵 안 됨)
    <br>* Tab: 밤(재생) ↔ 낮(정지) 수동 전환(낮으로 들어가면 CITY로 강제 복귀)
  </div>

  <!-- 오디오 -->
  <audio id="groan"></audio>
  <audio id="scratch" src="static/scratch.mp3" preload="auto"></audio>
  <audio id="gunshot" src="static/gunshot.mp3" preload="auto"></audio>

</div>

<script>
/* =========================================================
   리소스
   ========================================================= */
const cityNightImages = Array.from({length:5},(_,i)=>`static/city${i+1}.png`);
const cityDayImages   = Array.from({length:5},(_,i)=>`static/city-day${i+1}.png`);

/* ✅ 분리: 일반 좀비(1~5) / 특수 좀비(6~8) */
const zombieNormal = Array.from({length:5},(_,i)=>`static/zombie${i+1}.png`);
const zombieSpecial = Array.from({length:3},(_,i)=>`static/zombie${i+6}.png`);

const groanSounds  = Array.from({length:5},(_,i)=>`static/groan${i+1}.mp3`);

const puzzles = [
  { img:"static/puzzle4-1.png", answer:"1"},
  { img:"static/puzzle4-2.png", answer:"3" },
  { img:"static/puzzle4-3.png", answer:"4" },
  { img:"static/puzzle4-4.png", answer:"3" },
  { img:"static/puzzle4-5.png", answer:"2" },
  { img:"static/puzzle4-6.png", answer:"4" },
  { img:"static/puzzle4-7.png", answer:"3" }
];

/* =========================================================
   DOM
   ========================================================= */
const cityImg = document.getElementById("cityImg");
const zombieImg = document.getElementById("zombieImg");
const puzzleImg = document.getElementById("puzzleImg");
const timerEl = document.getElementById("timer");
const answerRow = document.getElementById("answerRow");
const answerInput = document.getElementById("answerInput");
const msgEl = document.getElementById("msg");

const groanEl = document.getElementById("groan");
const scratchEl = document.getElementById("scratch");
const gunshotEl = document.getElementById("gunshot");

const stopwatchEl = document.getElementById("stopwatch");
const modeLabelEl = document.getElementById("modeLabel");

/* =========================================================
   유틸
   ========================================================= */
const rand = arr => arr[Math.floor(Math.random()*arr.length)];
const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));

function playSound(el, src){
  try{
    if(src) el.src = src;
    el.pause();
    el.currentTime = 0;
    const p = el.play();
    if(p && p.catch) p.catch(()=>{});
  }catch(e){}
}
function warmUp(el, src){
  try{
    if(src) el.src = src;
    el.muted = true;
    const p = el.play();
    if(p && p.catch) p.catch(()=>{});
    el.pause();
    el.currentTime = 0;
    el.muted = false;
  }catch(e){}
}
function pad2(n){ return String(n).padStart(2,'0'); }
function formatStopwatch(ms){
  ms = Math.max(0, ms);
  const totalCs = Math.floor(ms / 10);
  const cs = totalCs % 100;
  const totalSec = Math.floor(totalCs / 100);
  const s = totalSec % 60;
  const m = Math.floor(totalSec / 60);
  return `${pad2(m)}:${pad2(s)}.${pad2(cs)}`;
}
function showMsg(text){
  msgEl.textContent = text;
  msgEl.classList.add("show");
}
function hideMsg(){
  msgEl.classList.remove("show");
}
function stopAllSfx(){
  try{ groanEl.pause(); groanEl.currentTime = 0; }catch(e){}
  try{ scratchEl.pause(); scratchEl.currentTime = 0; }catch(e){}
  try{ gunshotEl.pause(); gunshotEl.currentTime = 0; }catch(e){}
}

/* 한글 자모로 들어와도 영어로 자동 변환 */
function ko2enQwerty(s){
  const map = {
    'ㅂ':'q','ㅈ':'w','ㄷ':'e','ㄱ':'r','ㅅ':'t','ㅛ':'y','ㅕ':'u','ㅑ':'i','ㅐ':'o','ㅔ':'p',
    'ㅁ':'a','ㄴ':'s','ㅇ':'d','ㄹ':'f','ㅎ':'g','ㅗ':'h','ㅓ':'j','ㅏ':'k','ㅣ':'l',
    'ㅋ':'z','ㅌ':'x','ㅊ':'c','ㅍ':'v','ㅠ':'b','ㅜ':'n','ㅡ':'m'
  };
  return (s||"").split("").map(ch => map[ch] ?? ch).join("");
}

/* =========================================================
   상태
   ========================================================= */
let phase = "CITY";           // CITY | ZOMBIE | PUZZLE | RESULT
let puzzleIndex = 0;

let cityRafId = null;
let cityT0 = 0;

let zombieShownAt = null;

let zombieWaitMs = 0;
const ZOMBIE_WAIT_LIMIT_MS = 5000;

let puzzleLeftMs = 0;
const PUZZLE_LIMIT_MS = 20000;

let resultUntilMs = null;

/* ✅ 현재 좀비 타입/번호 */
let currentZombieNum = null;     // 1~8
let currentZombieType = "NORMAL"; // NORMAL | SPECIAL
function isSpecialZombie(){
  return currentZombieType === "SPECIAL";
}

/* =========================================================
   실행/정지 + 밤/낮
   ========================================================= */
let running = true;
let timeScale = 1;       // 1, 10, -10 (DAY에서는 0처럼 동작)
let lastPerfTs = 0;
let gameNowMs = 0;

let mode = "NIGHT";      // NIGHT / DAY

function isGameActive(){
  return running && mode === "NIGHT" && timeScale !== 0;
}
function updateTopUI(){
  stopwatchEl.textContent = formatStopwatch(gameNowMs);
  modeLabelEl.textContent = (mode === "NIGHT") ? "밤" : "낮";
}

/* =========================================================
   퍼즐 solved 스킵
   ========================================================= */
function nextUnsolvedIndex(from){
  for(let k=0; k<puzzles.length; k++){
    const i = (from + k) % puzzles.length;
    if(!puzzles[i].solved) return i;
  }
  return -1;
}
function resetSolvedAll(){
  puzzles.forEach(p => p.solved = false);
}

/* =========================================================
   CITY 이미지
   ========================================================= */
function setCityByMode(m){
  const src = (m === "DAY") ? rand(cityDayImages) : rand(cityNightImages);
  cityImg.src = src;
  cityImg.style.transform = "translateX(-50%) scale(1.1)";
}

/* =========================================================
   UI phase
   ========================================================= */
function setUIForPhase(){
  hideMsg();

  if(phase === "CITY"){
    zombieImg.style.display = "none";
    puzzleImg.style.display = "none";
    timerEl.style.display = "none";
    answerRow.style.display = "none";
  }else if(phase === "ZOMBIE"){
    zombieImg.style.display = "block";
    puzzleImg.style.display = "none";
    timerEl.style.display = "block";
    answerRow.style.display = "none";
  }else if(phase === "PUZZLE"){
    zombieImg.style.display = "block";
    puzzleImg.style.display = "block";
    timerEl.style.display = "block";
    answerRow.style.display = "block";
  }else{ // RESULT
    zombieImg.style.display = "block";
    puzzleImg.style.display = "block";
    timerEl.style.display = "none";
    answerRow.style.display = "none";
  }
}

/* =========================================================
   CITY 흔들림
   ========================================================= */
function startCityMotion(){
  if(cityRafId) cancelAnimationFrame(cityRafId);
  cityT0 = performance.now();
  const loop = (t)=>{
    if(phase !== "CITY" || !isGameActive()) return;
    const x = Math.sin((t-cityT0)/1000*0.6)*30;
    cityImg.style.transform = `translateX(calc(-50% + ${x}px)) scale(1.1)`;
    cityRafId = requestAnimationFrame(loop);
  };
  if(phase === "CITY" && isGameActive()){
    cityRafId = requestAnimationFrame(loop);
  }
}
function stopCityMotion(){
  if(cityRafId) cancelAnimationFrame(cityRafId);
  cityRafId = null;
}

/* =========================================================
   상태 전환
   ========================================================= */
function enterCity(){
  phase = "CITY";
  setUIForPhase();

  setCityByMode(mode);

  zombieShownAt = null;
  zombieWaitMs = 0;
  puzzleLeftMs = 0;
  resultUntilMs = null;

  currentZombieNum = null;
  currentZombieType = "NORMAL";

  if(isGameActive()) startCityMotion();
  else stopCityMotion();
}

function forceDayFreeze(){
  mode = "DAY";
  timeScale = 0;

  cancelEncounterToCity({ keepModeNight:false });
  setCityByMode("DAY");
  updateTopUI();
}

function resumeNightFromDay(){
  mode = "NIGHT";
  timeScale = 1;
  setCityByMode("NIGHT");

  phase = "CITY";
  setUIForPhase();

  zombieShownAt = null;
  zombieWaitMs = 0;
  puzzleLeftMs = 0;
  resultUntilMs = null;

  currentZombieNum = null;
  currentZombieType = "NORMAL";

  if(isGameActive()) startCityMotion();
  updateTopUI();
}

/* ✅ (요구) 타입을 지정해서 소환 */
function enterZombieWithType(type){
  if(!isGameActive()) return;
  if(phase !== "CITY") return;

  phase = "ZOMBIE";
  setUIForPhase();
  stopCityMotion();

  currentZombieType = (type === "SPECIAL") ? "SPECIAL" : "NORMAL";

  const zSrc = (currentZombieType === "SPECIAL") ? rand(zombieSpecial) : rand(zombieNormal);
  zombieImg.src = zSrc;
  zombieImg.style.display = "block";

  const m = /zombie(\d+)\.png$/i.exec(zSrc);
  currentZombieNum = m ? parseInt(m[1], 10) : null;

  // groan 랜덤 유지
  playSound(groanEl, rand(groanSounds));

  zombieShownAt = gameNowMs;

  zombieWaitMs = ZOMBIE_WAIT_LIMIT_MS;
  timerEl.textContent = "5";
}

function enterPuzzle(){
  phase = "PUZZLE";
  setUIForPhase();

  let ni = nextUnsolvedIndex(puzzleIndex);
  if(ni === -1){
    resetSolvedAll();
    ni = nextUnsolvedIndex(0);
    puzzleIndex = (ni === -1 ? 0 : ni);
  }else{
    puzzleIndex = ni;
  }

  const p = puzzles[puzzleIndex];
  puzzleImg.src = p.img;
  puzzleImg.style.display = "block";

  puzzleLeftMs = PUZZLE_LIMIT_MS;
  updatePuzzleTimerUI();

  answerInput.value = "";
  answerInput.focus();
}

function enterResult(imgSrc, soundType, msgText){
  phase = "RESULT";
  setUIForPhase();
  puzzleImg.src = imgSrc;

  if(msgText) showMsg(msgText);

  if(soundType === "SUCCESS"){
    try{ groanEl.pause(); groanEl.currentTime = 0; }catch(e){}
    playSound(gunshotEl);
  }else if(soundType === "FAIL"){
    playSound(scratchEl);
  }
}

/* ✅ SPECIAL(zombie6~8): Space 즉시 fail2 */
function doInstantFail2(){
  enterResult("static/fail2.png", "FAIL", "");
  resultUntilMs = gameNowMs + 20000; // 여기 숫자(ms) 바꾸면 fail2 유지시간 조절됨
}

function cancelEncounterToCity({ keepModeNight=true } = {}){
  if(keepModeNight){
    mode = "NIGHT";
    if(timeScale === 0) timeScale = 1;
  }

  zombieShownAt = null;
  zombieWaitMs = 0;
  puzzleLeftMs = 0;
  resultUntilMs = null;

  currentZombieNum = null;
  currentZombieType = "NORMAL";

  stopAllSfx();
  answerInput.value = "";
  hideMsg();

  phase = "CITY";
  setUIForPhase();
  setCityByMode(mode);

  if(isGameActive()) startCityMotion();
  else stopCityMotion();

  updateTopUI();
}

/* =========================================================
   퍼즐 타이머 표시
   ========================================================= */
function updatePuzzleTimerUI(){
  const sec = Math.ceil(puzzleLeftMs / 1000);
  timerEl.textContent = String(clamp(sec,0,999));
}

/* =========================================================
   정답 처리
   ========================================================= */
function doSuccess(){
  puzzles[puzzleIndex].solved = true;
  enterResult("static/success.png", "SUCCESS", "");
  puzzleIndex = (puzzleIndex + 1) % puzzles.length;
  resultUntilMs = gameNowMs + 3000;
}
function doFail(){
  enterResult("static/fail.png", "FAIL", "");
  puzzleIndex = (puzzleIndex + 1) % puzzles.length;
  resultUntilMs = gameNowMs + 3000;
}
function doDamage(){
  enterResult("static/fail.png", "FAIL");
  resultUntilMs = gameNowMs + 3000;
}

/* =========================================================
   스냅샷(되감기용) - 유지
   ========================================================= */
const SNAP_INTERVAL_MS = 500;
const MAX_HISTORY_MS = 60000;
let lastSnapAt = 0;
let history = [];

function captureState(){
  return {
    phase,
    puzzleIndex,
    puzzlesSolved: puzzles.map(p => !!p.solved),

    citySrc: cityImg.getAttribute("src") || "",
    zombieSrc: zombieImg.getAttribute("src") || "",
    puzzleSrc: puzzleImg.getAttribute("src") || "",

    cityTransform: cityImg.style.transform || "translateX(-50%) scale(1.1)",

    zombieShownAt,
    zombieWaitMs,

    puzzleLeftMs,
    resultUntilMs,

    mode,
    timeScale,

    zombieDisplay: zombieImg.style.display,
    puzzleDisplay: puzzleImg.style.display,
    timerDisplay: timerEl.style.display,
    answerDisplay: answerRow.style.display,
    timerText: timerEl.textContent || "",

    msgShown: msgEl.classList.contains("show"),
    msgText: msgEl.textContent || "",

    currentZombieNum,
    currentZombieType
  };
}

function restoreState(s){
  phase = s.phase;
  puzzleIndex = s.puzzleIndex;

  puzzles.forEach((p,i)=> p.solved = !!s.puzzlesSolved[i]);

  if(s.citySrc) cityImg.src = s.citySrc;
  if(s.zombieSrc) zombieImg.src = s.zombieSrc;
  if(s.puzzleSrc) puzzleImg.src = s.puzzleSrc;

  cityImg.style.transform = s.cityTransform || "translateX(-50%) scale(1.1)";

  zombieShownAt = s.zombieShownAt;
  zombieWaitMs = s.zombieWaitMs;

  puzzleLeftMs = s.puzzleLeftMs;
  resultUntilMs = s.resultUntilMs;

  mode = s.mode;
  timeScale = s.timeScale;

  currentZombieNum = (s.currentZombieNum == null) ? null : s.currentZombieNum;
  currentZombieType = s.currentZombieType || "NORMAL";

  setUIForPhase();
  zombieImg.style.display = s.zombieDisplay || zombieImg.style.display;
  puzzleImg.style.display = s.puzzleDisplay || puzzleImg.style.display;
  timerEl.style.display = s.timerDisplay || timerEl.style.display;
  answerRow.style.display = s.answerDisplay || answerRow.style.display;
  timerEl.textContent = s.timerText || timerEl.textContent;

  if(s.msgShown){
    showMsg(s.msgText || "");
  }else{
    hideMsg();
  }

  updateTopUI();
  if(phase === "CITY" && isGameActive()) startCityMotion();
  else stopCityMotion();
}

function pushSnapshot(){
  history.push({ t: gameNowMs, state: captureState() });
  const cutoff = gameNowMs - MAX_HISTORY_MS;
  while(history.length && history[0].t < cutoff) history.shift();
}
function findSnapshotAtOrBefore(target){
  if(history.length === 0) return null;
  for(let i = history.length - 1; i >= 0; i--){
    if(history[i].t <= target) return history[i];
  }
  return history[0];
}

/* =========================================================
   메인 루프
   ========================================================= */
function tick(perfTs){
  if(!running){
    lastPerfTs = perfTs;
    updateTopUI();
    requestAnimationFrame(tick);
    return;
  }

  if(!lastPerfTs) lastPerfTs = perfTs;
  const realDt = perfTs - lastPerfTs;
  lastPerfTs = perfTs;

  // DAY면 시간 정지
  if(mode === "DAY"){
    timeScale = 0;
    updateTopUI();
    if(gameNowMs - lastSnapAt >= SNAP_INTERVAL_MS){
      pushSnapshot();
      lastSnapAt = gameNowMs;
    }
    requestAnimationFrame(tick);
    return;
  }

  const dt = realDt * timeScale;

  // 되감기(-10)
  if(timeScale < 0){
    const newT = gameNowMs + dt;
    gameNowMs = Math.max(0, newT);

    const snap = findSnapshotAtOrBefore(gameNowMs);
    if(snap) restoreState(snap.state);

    updateTopUI();
    requestAnimationFrame(tick);
    return;
  }

  // 정방향
  gameNowMs += dt;
  updateTopUI();

  // ZOMBIE: 5초
  if(phase === "ZOMBIE"){
    zombieWaitMs -= dt;
    zombieWaitMs = Math.max(0, zombieWaitMs);
    timerEl.textContent = String(Math.ceil(zombieWaitMs / 1000));

    if(zombieWaitMs <= 0){
      if(isSpecialZombie()){
        // ✅ zombie6~8: 아무 효과 없이 사라짐
        enterCity();
      }else{
        // ✅ zombie1~5: 기존 데미지
        doDamage();
      }
    }
  }

  // PUZZLE: 20초
  if(phase === "PUZZLE"){
    puzzleLeftMs -= dt;
    puzzleLeftMs = Math.max(0, puzzleLeftMs);
    updatePuzzleTimerUI();

    if(puzzleLeftMs <= 0){
      doFail();
    }
  }

  // RESULT: 종료 시 CITY
  if(phase === "RESULT"){
    if(resultUntilMs != null && gameNowMs >= resultUntilMs){
      resultUntilMs = null;
      enterCity();
    }
  }

  // 스냅샷
  if(gameNowMs - lastSnapAt >= SNAP_INTERVAL_MS){
    pushSnapshot();
    lastSnapAt = gameNowMs;
  }

  requestAnimationFrame(tick);
}

/* =========================================================
   입력
   ========================================================= */
answerInput.addEventListener("input", ()=>{
  answerInput.value = answerInput.value.toUpperCase();
});

answerInput.addEventListener("keydown", (e)=>{
  if(e.key !== "Enter") return;
  if(phase !== "PUZZLE") return;

  const p = puzzles[puzzleIndex];

  const raw = (answerInput.value || "").trim();
  const u1 = raw.toUpperCase();
  const u2 = ko2enQwerty(raw).toUpperCase();

  if(u1 === p.answer || u2 === p.answer) doSuccess();
  else doFail();
});

window.addEventListener("keydown", (e)=>{
  // Tab 토글
  if(e.key === "Tab"){
    e.preventDefault();
    show("toggle");
    return;
  }

  // ✅ 0 = 일반좀비(1~5)
  if(e.key === "0"){
    e.preventDefault();
    if(isGameActive() && phase === "CITY"){
      enterZombieWithType("NORMAL");
    }
    return;
  }

  // ✅ '-' = 특수좀비(6~8)
  // (키보드 위치/레이아웃에 따라 e.key가 '-' 또는 'Minus'일 수 있어 둘 다 처리)
  if(e.key === "-" || e.code === "Minus"){
    e.preventDefault();
    if(isGameActive() && phase === "CITY"){
      enterZombieWithType("SPECIAL");
    }
    return;
  }

  // 9 = 취소
  if(e.key === "9"){
    if(phase === "ZOMBIE" || phase === "PUZZLE" || phase === "RESULT"){
      e.preventDefault();
      cancelEncounterToCity({ keepModeNight:true });
    }
    return;
  }

  // Space
  if(e.code === "Space"){
    if(phase === "ZOMBIE" && isGameActive()){
      e.preventDefault();
      if(isSpecialZombie()){
        // ✅ zombie6~8만 즉시 fail2
        doInstantFail2();
      }else{
        // ✅ zombie1~5는 퍼즐로
        enterPuzzle();
      }
      return;
    }
  }
});

/* =========================================================
   컨트롤
   ========================================================= */
let audioReady = false;

function hardResetGame(){
  phase = "CITY";
  puzzleIndex = 0;
  resetSolvedAll();

  zombieShownAt = null;
  zombieWaitMs = 0;

  puzzleLeftMs = 0;
  resultUntilMs = null;

  currentZombieNum = null;
  currentZombieType = "NORMAL";

  mode = "NIGHT";
  timeScale = 1;

  gameNowMs = 0;
  history = [];
  lastSnapAt = 0;

  enterCity();
  pushSnapshot();
  lastSnapAt = gameNowMs;
  updateTopUI();
}

function show(id){
  if(id === "restart"){
    if(!audioReady){
      warmUp(groanEl, groanSounds[0]);
      warmUp(scratchEl, "static/scratch.mp3");
      warmUp(gunshotEl, "static/gunshot.mp3");
      audioReady = true;
    }
    running = true;
    lastPerfTs = 0;
    hardResetGame();
    return;
  }

  if(id === "toggle"){
    if(mode === "NIGHT"){
      forceDayFreeze();
      pushSnapshot();
      lastSnapAt = gameNowMs;
      return;
    }else{
      lastPerfTs = 0;
      resumeNightFromDay();
      pushSnapshot();
      lastSnapAt = gameNowMs;
      return;
    }
  }

  if(id === "ff"){
    if(mode === "DAY") return;
    timeScale = 10;
    lastPerfTs = 0;
    if(phase === "CITY" && isGameActive()) startCityMotion();
    return;
  }

  if(id === "normal"){
    if(mode === "DAY") return;
    timeScale = 1;
    lastPerfTs = 0;
    if(phase === "CITY" && isGameActive()) startCityMotion();
    return;
  }

  if(id === "rew"){
    if(mode === "DAY") return;
    timeScale = -10;
    lastPerfTs = 0;
    stopCityMotion();
    return;
  }
}

/* =========================================================
   초기
   ========================================================= */
updateTopUI();
enterCity();
pushSnapshot();
requestAnimationFrame(tick);
</script>
</body>
</html>
