<!doctype html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>ZOMBIE CITY4</title>

<style>
body{
  margin:0;
  background:#ffffff;
  font-family: Arial, Helvetica, sans-serif;
  color:#111;
}
.wrap{ width:100%; text-align:center; }

.title{
  font-size:22px;
  font-weight:700;
  margin:18px 0 10px;
}

/* ✅ 카드 */
.card{
  width:1024px;
  height:768px;
  max-width:92vw;
  margin:0 auto;
  border:2px solid #111;
  position:relative;
  overflow:hidden;
  background:#fff;
}
.layer{
  position:absolute;
  inset:0;
  display:flex;
  align-items:center;
  justify-content:center;
}

/* ✅ city 흔들림 */
#cityImg{
  height:100%;
  width:auto;
  position:absolute;
  left:50%;
  transform:translateX(-50%);
  user-select:none;
  pointer-events:none;
}

/* ✅ overlays */
#zombieImg,#puzzleImg{
  width:100%;
  height:100%;
  object-fit:contain;
  display:none;
  user-select:none;
  pointer-events:none;
}

/* ✅ 퍼즐 UI */
.ui{
  width:1024px;
  max-width:92vw;
  margin:10px auto 0;
}
.timer{
  font-family: ui-monospace, monospace;
  font-size:48px;
  display:none;
}
.answerRow{
  display:none;
  margin-top:8px;
}
input{
  border:2px solid #111;
  padding:12px;
  font-size:18px;
  width:260px;
  text-align:center;
}

/* ✅ 상단 컨트롤: [다시시작] [02:00 + 밤/낮] [▶/II][>>][<<] */
.controls{
  width:1024px;
  max-width:92vw;
  margin:14px auto 10px;
  display:grid;
  grid-template-columns: 1fr auto auto;
  gap:10px;
  align-items:center;
}
.ctrlLeft{
  display:flex;
  justify-content:flex-start;
}
.ctrlMid{
  display:flex;
  justify-content:center;
  gap:12px;
  align-items:center;
  border:2px solid #111;
  padding:10px 12px;
  box-sizing:border-box;
}
#cycleClock{
  font-family: ui-monospace, monospace;
  font-size:22px;
  letter-spacing:1px;
  min-width:72px;
}
#cycleLabel{
  font-weight:700;
  font-size:18px;
  min-width:36px;
}
.ctrlRight{
  display:flex;
  justify-content:flex-end;
  gap:10px;
}

button{
  border:2px solid #111;
  background:#fff;
  padding:12px;
  font-size:16px;
  cursor:pointer;
}
button:active{ transform: translateY(1px); }

.note{
  width:1024px;
  max-width:92vw;
  margin:0 auto 14px;
  font-size:12px;
  opacity:0.75;
  text-align:left;
}
</style>
</head>

<body>
<div class="wrap">

  <div class="title">ZOMBIE CITY4</div>

  <div class="controls">
    <div class="ctrlLeft">
      <button onclick="show('restart')">다시 시작</button>
    </div>

    <div class="ctrlMid">
      <div id="cycleClock">02:00</div>
      <div id="cycleLabel">밤</div>
    </div>

    <div class="ctrlRight">
      <button onclick="show('toggle')">▶/ II</button>
      <button onclick="show('ff')">앞으로 빨리감기</button>
      <button onclick="show('rew')">뒤로 빨리감기</button>
    </div>
  </div>

  <div class="card">
    <div class="layer"><img id="cityImg"></div>
    <div class="layer"><img id="zombieImg"></div>
    <div class="layer"><img id="puzzleImg"></div>
  </div>

  <div class="ui">
    <div id="timer" class="timer">20</div>
    <div id="answerRow" class="answerRow">
      <input id="answerInput"
             placeholder="ANSWER"
             autocomplete="off"
             autocapitalize="characters"
             autocorrect="off"
             spellcheck="false"
             inputmode="latin"
             lang="en">
      <div>ENTER 누르기</div>
    </div>
  </div>

  <div class="note">
    * 밤(진행) 2분 ↔ 낮(정지) 2분 반복. 낮 전환 순간 퍼즐/좀비가 떠 있어도 CITY(낮 배경)로 강제 복귀.
  </div>

  <!-- 오디오 -->
  <audio id="groan"></audio>
  <audio id="scratch" src="static/scratch.mp3" preload="auto"></audio>
  <audio id="gunshot" src="static/gunshot.mp3" preload="auto"></audio>

</div>

<script>
/* =========================================================
   리소스
   ========================================================= */
const cityNightImages = Array.from({length:5},(_,i)=>`static/city${i+1}.png`);
const cityDayImages   = Array.from({length:5},(_,i)=>`static/city-day${i+1}.png`);

const zombieImages = Array.from({length:5},(_,i)=>`static/zombie${i+1}.png`);
const groanSounds  = Array.from({length:9},(_,i)=>`static/groan${i+1}.mp3`);

const puzzles = [
  { img:"static/puzzle4-1.png", answer:"1"},
  { img:"static/puzzle4-2.png", answer:"3" },
  { img:"static/puzzle4-3.png", answer:"4" },
  { img:"static/puzzle4-4.png", answer:"3" },
  { img:"static/puzzle4-5.png", answer:"2" },
  { img:"static/puzzle4-6.png", answer:"4" },
  { img:"static/puzzle4-7.png", answer:"3" }
];


/* =========================================================
   DOM
   ========================================================= */
const cityImg = document.getElementById("cityImg");
const zombieImg = document.getElementById("zombieImg");
const puzzleImg = document.getElementById("puzzleImg");
const timerEl = document.getElementById("timer");
const answerRow = document.getElementById("answerRow");
const answerInput = document.getElementById("answerInput");

const groanEl = document.getElementById("groan");
const scratchEl = document.getElementById("scratch");
const gunshotEl = document.getElementById("gunshot");

const cycleClockEl = document.getElementById("cycleClock");
const cycleLabelEl = document.getElementById("cycleLabel");

/* =========================================================
   유틸
   ========================================================= */
const rand = arr => arr[Math.floor(Math.random()*arr.length)];
const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));

function playSound(el, src){
  try{
    if(src) el.src = src;
    el.pause();
    el.currentTime = 0;
    const p = el.play();
    if(p && p.catch) p.catch(()=>{});
  }catch(e){}
}
function warmUp(el, src){
  try{
    if(src) el.src = src;
    el.muted = true;
    const p = el.play();
    if(p && p.catch) p.catch(()=>{});
    el.pause();
    el.currentTime = 0;
    el.muted = false;
  }catch(e){}
}
function pad2(n){ return String(n).padStart(2,'0'); }

/* 한글 자모로 들어와도 영어로 자동 변환 */
function ko2enQwerty(s){
  const map = {
    'ㅂ':'q','ㅈ':'w','ㄷ':'e','ㄱ':'r','ㅅ':'t','ㅛ':'y','ㅕ':'u','ㅑ':'i','ㅐ':'o','ㅔ':'p',
    'ㅁ':'a','ㄴ':'s','ㅇ':'d','ㄹ':'f','ㅎ':'g','ㅗ':'h','ㅓ':'j','ㅏ':'k','ㅣ':'l',
    'ㅋ':'z','ㅌ':'x','ㅊ':'c','ㅍ':'v','ㅠ':'b','ㅜ':'n','ㅡ':'m'
  };
  return (s||"").split("").map(ch => map[ch] ?? ch).join("");
}

/* =========================================================
   게임 상태
   ========================================================= */
let phase = "CITY";           // CITY | ZOMBIE | PUZZLE | RESULT
let puzzleIndex = 0;

let cityRafId = null;
let cityT0 = 0;

let zombiePendingAt = null;   // (게임시간 기준) 좀비 등장 예약
let zombieShownAt = null;     // 좀비 표시 시작
let puzzleShownAt = null;     // 퍼즐 표시 시작

let puzzleLeftMs = 0;
const PUZZLE_LIMIT_MS = 20000;

let resultUntilMs = null;

/* ✅ "현재 밤의 (step)에서 이미 한 번 쐈는지" 기록 */
let lastStepFired = -1;

/* =========================================================
   2분 밤/낮 사이클 + 빨리감기/되감기
   ========================================================= */
let running = false;
let timeScale = 1;      // 1, 10, -10
let lastPerfTs = 0;
let gameNowMs = 0;

const CYCLE_LEN_MS = 120000;  // 2분
let cycleRemainingMs = CYCLE_LEN_MS;
let cycleMode = "NIGHT";      // NIGHT(진행) / DAY(정지)

/* ✅ 밤 번호(1박,2박...) : "DAY->NIGHT 전환" 때마다 +1
   - restart 시 0으로 초기화
   - 각 밤마다 시퀀스가 달라지게 만드는 핵심 */
let nightIndex = 0;

function isGameActive(){
  return running && cycleMode === "NIGHT" && timeScale !== 0;
}

function updateCycleUI(){
  const sec = Math.ceil(cycleRemainingMs / 1000);
  const m = Math.floor(sec / 60);
  const s = sec % 60;
  cycleClockEl.textContent = `${pad2(m)}:${pad2(s)}`;
  cycleLabelEl.textContent = (cycleMode === "NIGHT") ? "밤" : "낮";
}

/* =========================================================
   ✅ 새 스케줄: 밤(120초) 동안 0/20/40/60/80/100초에만 좀비 트리거
   + "restart 직후" / "DAY->NIGHT 직후" 2초 안에 뜨게: STEP_GRACE_MS
   ========================================================= */
const NIGHT_LEN_MS     = 120000;
const STEP_MS          = 20000;
const STEPS_PER_NIGHT  = 6;
const STEP_GRACE_MS    = 2000; // ✅ 슬롯 시작 후 2초까지는 그 슬롯로 인정

const PAGE_ID = 4; // ✅ page1은 1 / page2는 2 / page3는 3 / page4는 4 로만 바꾸면 됨

function rng32(seed){
  seed = (seed * 1664525 + 1013904223) >>> 0;
  return seed;
}

/* ✅ "밤마다" 6개(0/20/40/60/80/100)의 페이지 순서 생성 */
function makeNightSequence(nIdx){
  let seed = ((nIdx + 1) * 2654435761) >>> 0;
  const seq = [];
  let prev = -1;
  for(let i=0;i<STEPS_PER_NIGHT;i++){
    seed = rng32(seed);
    let pick = (seed % 4) + 1;

    // 뭉침 완화(연속 중복 한번 방지)
    if(pick === prev){
      seed = rng32(seed);
      pick = (seed % 4) + 1;
      if(pick === prev) pick = (prev % 4) + 1;
    }
    seq.push(pick);
    prev = pick;
  }
  return seq;
}

/* ✅ 현재 NIGHT에서 "다음 좀비 트리거" 계산
   - 핵심 수정:
     1) triggerAt >= gameNowMs 로 바꿔서 "0초 슬롯"도 안 놓치게
     2) 슬롯 시작 후 2초 grace 내면, 내 차례면 즉시(now)로 처리 */
function computeNextZombieAt_fixedSteps(){
  if(!isGameActive()) return null;

  // NIGHT에서 이미 지난 시간(0~120000)
  const nightElapsed = NIGHT_LEN_MS - cycleRemainingMs; // 0이면 막 시작한 밤
  const nightStartMs = gameNowMs - nightElapsed;

  const seq = makeNightSequence(nightIndex);

  // ✅ "지금이 어느 스텝인지" (0~5)
  const curStep = Math.floor(nightElapsed / STEP_MS);
  if(curStep >= 0 && curStep < STEPS_PER_NIGHT){
    const stepStart = curStep * STEP_MS;
    const sinceStepStart = nightElapsed - stepStart;

    // ✅ 슬롯 시작 후 2초 내 + 내 차례 + 아직 발사 안했으면 => 즉시 트리거
    if(sinceStepStart <= STEP_GRACE_MS && seq[curStep] === PAGE_ID){
      const key = nightIndex * 10 + curStep;
      if(lastStepFired !== key){
        lastStepFired = key;
        return gameNowMs; // 즉시
      }
    }
  }

  // ✅ 다음 스텝부터 앞으로 훑어서 내 차례 찾기
  let nextStep = Math.ceil(nightElapsed / STEP_MS);
  if(nextStep < 0) nextStep = 0;

  for(let s = nextStep; s < STEPS_PER_NIGHT; s++){
    if(seq[s] === PAGE_ID){
      const key = nightIndex * 10 + s;
      if(lastStepFired === key) continue;

      const triggerAt = nightStartMs + s * STEP_MS; // 0/20/40/...
      if(triggerAt >= gameNowMs){
        return triggerAt;
      }
    }
  }

  // 이번 밤에서 내 차례가 더 없으면 => "다음 밤"의 가장 빠른 내 차례
  // (next night는 DAY 2분 지나고 NIGHT 시작이므로 여기선 예약만 해둠)
  // 실제로는 DAY때 isGameActive가 false라 tick에서 바로 쓰지 않지만,
  // NIGHT 들어오면 다시 computeNextZombieAt_fixedSteps()로 재계산됨.
  const nextNightStart = nightStartMs + (NIGHT_LEN_MS + CYCLE_LEN_MS); // NIGHT(120s)+DAY(120s)=240s
  const nextSeq = makeNightSequence(nightIndex + 1);

  for(let s = 0; s < STEPS_PER_NIGHT; s++){
    if(nextSeq[s] === PAGE_ID){
      return nextNightStart + s * STEP_MS;
    }
  }
  return nextNightStart;
}

/* =========================================================
   퍼즐 solved 스킵(전부 맞추면 초기화 후 순환)
   ========================================================= */
function nextUnsolvedIndex(from){
  for(let k=0; k<puzzles.length; k++){
    const i = (from + k) % puzzles.length;
    if(!puzzles[i].solved) return i;
  }
  return -1;
}
function resetSolvedAll(){
  puzzles.forEach(p => p.solved = false);
}

/* =========================================================
   CITY 이미지: 밤/낮 모드에 따라 랜덤 교체
   ========================================================= */
function setCityByMode(mode){
  const src = (mode === "DAY") ? rand(cityDayImages) : rand(cityNightImages);
  cityImg.src = src;
  cityImg.style.transform = "translateX(-50%) scale(1.1)";
}

/* =========================================================
   UI phase
   ========================================================= */
function setUIForPhase(){
  if(phase === "CITY"){
    zombieImg.style.display = "none";
    puzzleImg.style.display = "none";
    timerEl.style.display = "none";
    answerRow.style.display = "none";
  }else if(phase === "ZOMBIE"){
    zombieImg.style.display = "block";
    puzzleImg.style.display = "none";
    timerEl.style.display = "none";
    answerRow.style.display = "none";
  }else if(phase === "PUZZLE"){
    zombieImg.style.display = "block";
    puzzleImg.style.display = "block";
    timerEl.style.display = "block";
    answerRow.style.display = "block";
  }else{
    zombieImg.style.display = "block";
    puzzleImg.style.display = "block";
    timerEl.style.display = "none";
    answerRow.style.display = "none";
  }
}

/* =========================================================
   CITY 흔들림
   ========================================================= */
function startCityMotion(){
  if(cityRafId) cancelAnimationFrame(cityRafId);
  cityT0 = performance.now();
  const loop = (t)=>{
    if(phase !== "CITY" || !isGameActive()) return;
    const x = Math.sin((t-cityT0)/1000*0.6)*30;
    cityImg.style.transform = `translateX(calc(-50% + ${x}px)) scale(1.1)`;
    cityRafId = requestAnimationFrame(loop);
  };
  if(phase === "CITY" && isGameActive()){
    cityRafId = requestAnimationFrame(loop);
  }
}
function stopCityMotion(){
  if(cityRafId) cancelAnimationFrame(cityRafId);
  cityRafId = null;
}

/* =========================================================
   상태 전환
   ========================================================= */
function enterCity(){
  phase = "CITY";
  setUIForPhase();

  setCityByMode(cycleMode);

  zombiePendingAt = computeNextZombieAt_fixedSteps();
  zombieShownAt = null;
  puzzleShownAt = null;
  puzzleLeftMs = 0;

  if(isGameActive()) startCityMotion();
  else stopCityMotion();
}

function forceDayCityFreeze(){
  phase = "CITY";
  setUIForPhase();
  setCityByMode("DAY");

  zombiePendingAt = null;
  zombieShownAt = null;
  puzzleShownAt = null;
  puzzleLeftMs = 0;
  resultUntilMs = null;

  stopCityMotion();
}

function enterZombie(){
  phase = "ZOMBIE";
  setUIForPhase();
  stopCityMotion();

  zombieImg.src = rand(zombieImages);
  zombieImg.style.display = "block";

  playSound(groanEl, rand(groanSounds));

  zombieShownAt = gameNowMs;
  puzzleShownAt = null;
}

function enterPuzzle(){
  phase = "PUZZLE";
  setUIForPhase();

  let ni = nextUnsolvedIndex(puzzleIndex);
  if(ni === -1){
    resetSolvedAll();
    ni = nextUnsolvedIndex(0);
    puzzleIndex = (ni === -1 ? 0 : ni);
  }else{
    puzzleIndex = ni;
  }

  const p = puzzles[puzzleIndex];
  puzzleImg.src = p.img;
  puzzleImg.style.display = "block";

  puzzleLeftMs = PUZZLE_LIMIT_MS;
  updatePuzzleTimerUI();

  answerInput.value = "";
  answerInput.focus();

  puzzleShownAt = gameNowMs;
}

function enterResult(imgSrc, soundType){
  phase = "RESULT";
  setUIForPhase();
  puzzleImg.src = imgSrc;

  if(soundType === "SUCCESS"){
    try{ groanEl.pause(); groanEl.currentTime = 0; }catch(e){}
    playSound(gunshotEl);
  }else if(soundType === "FAIL"){
    playSound(scratchEl);
  }
}

/* =========================================================
   퍼즐 타이머 표시
   ========================================================= */
function updatePuzzleTimerUI(){
  const sec = Math.ceil(puzzleLeftMs / 1000);
  timerEl.textContent = String(clamp(sec,0,999));
}

/* =========================================================
   정답 처리
   ========================================================= */
function doSuccess(){
  puzzles[puzzleIndex].solved = true;

  enterResult("static/success.png", "SUCCESS");
  puzzleIndex = (puzzleIndex + 1) % puzzles.length;

  resultUntilMs = gameNowMs + 3000;
}
function doFail(){
  enterResult("static/fail.png", "FAIL");
  puzzleIndex = (puzzleIndex + 1) % puzzles.length;

  resultUntilMs = gameNowMs + 3000;
}

/* =========================================================
   스냅샷(되감기용)
   ========================================================= */
const SNAP_INTERVAL_MS = 500;
const MAX_HISTORY_MS = 60000;
let lastSnapAt = 0;
let history = [];

function captureState(){
  return {
    phase,
    puzzleIndex,
    puzzlesSolved: puzzles.map(p => !!p.solved),

    citySrc: cityImg.getAttribute("src") || "",
    zombieSrc: zombieImg.getAttribute("src") || "",
    puzzleSrc: puzzleImg.getAttribute("src") || "",

    cityTransform: cityImg.style.transform || "translateX(-50%) scale(1.1)",

    zombiePendingAt,
    zombieShownAt,
    puzzleShownAt,

    puzzleLeftMs,
    resultUntilMs,

    cycleRemainingMs,
    cycleMode,

    nightIndex,
    lastStepFired,

    zombieDisplay: zombieImg.style.display,
    puzzleDisplay: puzzleImg.style.display,
    timerDisplay: timerEl.style.display,
    answerDisplay: answerRow.style.display,
    timerText: timerEl.textContent || ""
  };
}

function restoreState(s){
  phase = s.phase;
  puzzleIndex = s.puzzleIndex;

  puzzles.forEach((p,i)=> p.solved = !!s.puzzlesSolved[i]);

  if(s.citySrc) cityImg.src = s.citySrc;
  if(s.zombieSrc) zombieImg.src = s.zombieSrc;
  if(s.puzzleSrc) puzzleImg.src = s.puzzleSrc;

  cityImg.style.transform = s.cityTransform || "translateX(-50%) scale(1.1)";

  zombiePendingAt = s.zombiePendingAt;
  zombieShownAt = s.zombieShownAt;
  puzzleShownAt = s.puzzleShownAt;

  puzzleLeftMs = s.puzzleLeftMs;
  resultUntilMs = s.resultUntilMs;

  cycleRemainingMs = s.cycleRemainingMs;
  cycleMode = s.cycleMode;

  nightIndex = s.nightIndex ?? nightIndex;
  lastStepFired = s.lastStepFired ?? lastStepFired;

  setUIForPhase();
  zombieImg.style.display = s.zombieDisplay || zombieImg.style.display;
  puzzleImg.style.display = s.puzzleDisplay || puzzleImg.style.display;
  timerEl.style.display = s.timerDisplay || timerEl.style.display;
  answerRow.style.display = s.answerDisplay || answerRow.style.display;
  timerEl.textContent = s.timerText || timerEl.textContent;

  updateCycleUI();

  if(phase === "CITY" && isGameActive()) startCityMotion();
  else stopCityMotion();
}

function pushSnapshot(){
  history.push({ t: gameNowMs, state: captureState() });
  const cutoff = gameNowMs - MAX_HISTORY_MS;
  while(history.length && history[0].t < cutoff) history.shift();
}

function findSnapshotAtOrBefore(target){
  if(history.length === 0) return null;
  for(let i = history.length - 1; i >= 0; i--){
    if(history[i].t <= target) return history[i];
  }
  return history[0];
}

/* =========================================================
   메인 루프
   ========================================================= */
function tick(perfTs){
  if(!running){
    lastPerfTs = perfTs;
    requestAnimationFrame(tick);
    return;
  }

  if(!lastPerfTs) lastPerfTs = perfTs;
  const realDt = perfTs - lastPerfTs;
  lastPerfTs = perfTs;

  const dt = realDt * timeScale;

  // 되감기
  if(timeScale < 0){
    const newT = gameNowMs + dt;
    gameNowMs = Math.max(0, newT);

    const snap = findSnapshotAtOrBefore(gameNowMs);
    if(snap) restoreState(snap.state);

    requestAnimationFrame(tick);
    return;
  }

  // 정방향
  gameNowMs += dt;

  // 2분 사이클(밤/낮)
  cycleRemainingMs -= dt;
  if(cycleRemainingMs <= 0){
    while(cycleRemainingMs <= 0) cycleRemainingMs += CYCLE_LEN_MS;

    if(cycleMode === "NIGHT"){
      // NIGHT -> DAY
      cycleMode = "DAY";
      updateCycleUI();
      forceDayCityFreeze();
    }else{
      // DAY -> NIGHT
      cycleMode = "NIGHT";
      nightIndex += 1;                 // ✅ 밤 카운터 증가(중요)
      lastStepFired = -1;              // ✅ 새 밤 시작이므로 발사기록 초기화(간단/안전)
      updateCycleUI();

      setCityByMode("NIGHT");
      if(phase === "CITY") startCityMotion();

      // ✅ "낮에서 밤으로 넘어오면 2초 안에"도 여기서 바로 계산(필요시 즉시 발사됨)
      if(phase === "CITY") zombiePendingAt = computeNextZombieAt_fixedSteps();
    }
  }else{
    updateCycleUI();
  }

  // DAY면 진행 멈춤
  if(!isGameActive()){
    if(gameNowMs - lastSnapAt >= SNAP_INTERVAL_MS){
      pushSnapshot();
      lastSnapAt = gameNowMs;
    }
    requestAnimationFrame(tick);
    return;
  }

  // CITY
  if(phase === "CITY"){
    if(zombiePendingAt == null) zombiePendingAt = computeNextZombieAt_fixedSteps();
    if(zombiePendingAt != null && gameNowMs >= zombiePendingAt){
      zombiePendingAt = null; // ✅ 중복 방지
      enterZombie();
    }
  }

  // ZOMBIE: 2초 후 퍼즐(요구대로 유지)
  if(phase === "ZOMBIE"){
    if(zombieShownAt != null && gameNowMs - zombieShownAt >= 2000){
      enterPuzzle();
    }
  }

  // PUZZLE: 카운트다운
  if(phase === "PUZZLE"){
    puzzleLeftMs -= dt;
    puzzleLeftMs = Math.max(0, puzzleLeftMs);
    updatePuzzleTimerUI();

    if(puzzleLeftMs <= 0){
      doFail();
    }
  }

  // RESULT: 3초 후 CITY 복귀
  if(phase === "RESULT"){
    if(resultUntilMs != null && gameNowMs >= resultUntilMs){
      resultUntilMs = null;
      enterCity();
    }
  }

  // 스냅샷
  if(gameNowMs - lastSnapAt >= SNAP_INTERVAL_MS){
    pushSnapshot();
    lastSnapAt = gameNowMs;
  }

  requestAnimationFrame(tick);
}

/* =========================================================
   입력
   ========================================================= */
answerInput.addEventListener("input", ()=>{
  answerInput.value = answerInput.value.toUpperCase();
});

answerInput.addEventListener("keydown", (e)=>{
  if(e.key !== "Enter") return;
  if(phase !== "PUZZLE") return;

  const p = puzzles[puzzleIndex];

  const raw = (answerInput.value || "").trim();
  const u1 = raw.toUpperCase();
  const u2 = ko2enQwerty(raw).toUpperCase();

  if(u1 === p.answer || u2 === p.answer) doSuccess();
  else doFail();
});

/* =========================================================
   컨트롤
   ========================================================= */
let audioReady = false;

function hardResetGame(){
  phase = "CITY";
  puzzleIndex = 0;
  resetSolvedAll();

  zombiePendingAt = null;
  zombieShownAt = null;
  puzzleShownAt = null;

  puzzleLeftMs = 0;
  resultUntilMs = null;

  // 2분 사이클: 밤부터
  cycleMode = "NIGHT";
  cycleRemainingMs = CYCLE_LEN_MS;
  updateCycleUI();

  // ✅ restart 시 밤번호 0부터 (여기서 바로 0초 슬롯을 "2초 grace"로 잡음)
  nightIndex = 0;
  lastStepFired = -1;

  gameNowMs = 0;
  history = [];
  lastSnapAt = 0;

  enterCity(); // enterCity 내부에서 computeNextZombieAt_fixedSteps() 수행(즉시 트리거 가능)
  pushSnapshot();
  lastSnapAt = gameNowMs;
}

function show(id){
  if(id === "restart"){
    if(!audioReady){
      warmUp(groanEl, groanSounds[0]);
      warmUp(scratchEl, "static/scratch.mp3");
      warmUp(gunshotEl, "static/gunshot.mp3");
      audioReady = true;
    }
    timeScale = 1;
    running = true;
    lastPerfTs = 0;
    hardResetGame();
    return;
  }

  if(id === "toggle"){
    // 멈추기
    if(running){
      running = false;
      stopCityMotion();
      return;
    }
    // 재개: 정속
    timeScale = 1;
    running = true;
    lastPerfTs = 0;
    if(phase === "CITY" && cycleMode === "NIGHT") startCityMotion();
    return;
  }

  if(id === "ff"){
    timeScale = 10;
    running = true;
    lastPerfTs = 0;
    if(phase === "CITY" && isGameActive()) startCityMotion();
    return;
  }

  if(id === "rew"){
    timeScale = -10;
    running = true;
    lastPerfTs = 0;
    stopCityMotion();
    return;
  }
}

/* =========================================================
   초기: 화면만 준비(자동 시작 X)
   ========================================================= */
updateCycleUI();
enterCity();
pushSnapshot();
requestAnimationFrame(tick);
</script>
</body>
</html>
